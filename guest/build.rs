use serde::Deserialize;
use std::collections::HashMap;
use std::env;
use std::fs;
use std::path::Path;

#[derive(Deserialize)]
struct SpriteSheet {
    frames: HashMap<String, FrameEntry>,
    meta: Meta,
}

#[derive(Deserialize)]
struct FrameEntry {
    frame: Rect,
    duration: u32,
}

#[derive(Deserialize)]
struct Rect {
    x: u16,
    y: u16,
    w: u16,
    h: u16,
}

#[derive(Deserialize)]
struct Meta {
    #[serde(rename = "frameTags")]
    frame_tags: Vec<FrameTag>,
}

#[derive(Deserialize)]
struct FrameTag {
    name: String,
    from: u16,
    to: u16,
    #[allow(dead_code)]
    direction: String,
}

fn main() {
    let json = fs::read_to_string("assets/anim-0002.json").unwrap();
    let sheet: SpriteSheet = serde_json::from_str(&json).unwrap();

    // Sort frames by name to get correct ordering
    let mut frames: Vec<_> = sheet.frames.into_iter().collect();
    frames.sort_by(|a, b| a.0.cmp(&b.0));

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest = Path::new(&out_dir).join("anim0002.rs");

    let mut code = String::new();

    code.push_str("// This file is auto-generated by build.rs from anim-0002.json\n");
    code.push_str("// Do not edit this file directly\n\n");

    code.push_str("#[allow(dead_code)]\n");
    code.push_str(&format!(
        "pub const FRAME_COUNT: usize = {};\n\n",
        frames.len()
    ));

    code.push_str("#[allow(dead_code)]\n");
    code.push_str("#[derive(Clone, Copy)]\npub struct Frame {\n    pub x: u16,\n    pub y: u16,\n    pub w: u16,\n    pub h: u16,\n    pub duration_ms: u32,\n}\n\n");

    code.push_str("#[allow(dead_code)]\n");
    code.push_str("#[derive(Clone, Copy)]\npub struct FrameTag {\n    pub name: &'static str,\n    pub from: u16,\n    pub to: u16,\n}\n\n");

    code.push_str("#[allow(dead_code)]\n");
    code.push_str("pub static FRAMES: [Frame; FRAME_COUNT] = [\n");
    for (_, entry) in &frames {
        code.push_str(&format!(
            "    Frame {{ x: {}, y: {}, w: {}, h: {}, duration_ms: {} }},\n",
            entry.frame.x, entry.frame.y, entry.frame.w, entry.frame.h, entry.duration
        ));
    }
    code.push_str("];\n\n");

    code.push_str("#[allow(dead_code)]\n");
    code.push_str(&format!(
        "pub static FRAME_TAGS: [FrameTag; {}] = [\n",
        sheet.meta.frame_tags.len()
    ));
    for tag in &sheet.meta.frame_tags {
        code.push_str(&format!(
            "    FrameTag {{ name: \"{}\", from: {}, to: {} }},\n",
            tag.name, tag.from, tag.to
        ));
    }
    code.push_str("];\n\n");

    // Construct a table of Frame offsets and the cumulative duration to each frame,
    // allowing a quick look-up of the current frame based on elapsed time.
    //
    // Based on 256 ticks per second, and JSON duration in milliseconds, the output should look something like:
    //
    // pub static FRAME_OFFSETS: [(usize, u32); FRAME_COUNT] = [
    //     (0, 256),   // Frame 0 starts at offset 0, until 256 ticks have elapsed
    //     (768, 512), // Frame 1 starts at offset 768
    //     (1536, 768), // Frame 2 starts at offset 1536
    //     (2304, 832), // Frame 3 starts at offset 2304
    //     (3072, 896), // Frame 4 starts at offset 3072
    //     (3840, 1024), // Frame 5 starts at offset 3840
    // ];
    // The last frame's cumulative duration (1024 ticks) indicates the total duration of the
    // animation loop, after which it should repeat back to the first frame.

    code.push_str("#[allow(dead_code)]\n");
    code.push_str("pub static FRAME_OFFSETS: [(usize, u64); FRAME_COUNT] = [\n");
    let mut cumulative_duration = 0;
    for (i, (_, entry)) in frames.iter().enumerate() {
        let offset = i * 16 * 16 * 3; // Each frame is 16x16 pixels, 3 bytes per pixel
        cumulative_duration += entry.duration * 256 / 1000; // Convert ms to ticks (256 ticks per second)
        code.push_str(&format!("    ({}, {}),\n", offset, cumulative_duration));
    }
    code.push_str("];\n");

    fs::write(dest, code).unwrap();
    println!("cargo:rerun-if-changed=assets/anim-0002.json");
}
